<!DOCTYPE html>
<html>
<head id="httpflies-head">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Resphrame - The Awfully Named Responsive Web Design Testing Tool.</title>
    <meta charset="utf-8">
    <meta name="title" content="Resphrame - The Awfully Named Responsive Web Design Testing Tool.">
    <meta name="author" content="Tom Morgan - Morganesque - http://morganesque.com/">
    <meta name="Copyright" content="Copyright Tom Morgan 2013. All Rights Reserved.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { background-color: #D7D6D7; font-family: sans-serif; }
        .handle { display: block; position: absolute; width: 110px; height: 50px; top: 50px; left: 100%; background: black; text-decoration: none; color: white; text-align: center; line-height: 50px; cursor: col-resize; white-space: nowrap; }
        .wrapper { display: block; width: 320px; height: 100%; margin: 0 auto; border: none; background-color: white; -webkit-box-shadow: 0px 0px 76px 5px rgba(0, 0, 0, 0.19); box-shadow: 0px 0px 76px 5px rgba(0, 0, 0, 0.19); }
        .cover { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 20; cursor: col-resize; background-color: rgba(0, 0, 0, 0.1); }
        iframe { width: 100%; height: 100%; /* pointer-events: none; */ border: none; }
        #test { position: absolute; top: 0; left: 0; background: white; padding: 0.5em; }
        iframe::-webkit-scrollbar { display: none; }
        iframe::-moz-scrollbar { display:none; }
        .controls { position: absolute; display: block; top: 0px; left: -334px; padding: 0; background: black; color: white; -webkit-transition: left 0.5s ease-out; -moz-transition: left 0.5s ease-out; -o-transition: left 0.5s ease-out; transition: left 0.5s ease-out; }
        .controls:hover { left: 0; }
        .marks { top: 38px; left: -214px; }
        .marks input { width: 200px; }
        .info { top: 76px; left: 0px; }
        .book { position: absolute; bottom: 0px; left: 0px; padding: 0.5em; font-size: 0.88em; }
        .book p { font-size: 0.88em; margin-bottom: 0.25em; }
        .book a, .info a { padding: 8px; background: white; font-size: 0.88em; line-height: 32px; text-decoration: none; color: blue; }
        .info a:focus, .info a:hover { color: red; }
        label { font-size: 0.88em; background: black; line-height: 32px; }
        label.controls input { margin-right: 8px; }
        label.controls { padding-right: 8px; }
        input { border: none; outline: none; margin: 0; padding: 7px; width: 320px; height: 22px; font-family: monospace; }
        input:focus { margin: 0; padding: 7px; border: none; outline: none; }
        .markers { position: absolute; width: 50%; height: 100%; top: 0; left: 50%; }
        .mark { height: 100%; border-left: 1px solid rgba(255, 255, 255, 0.42); color: rgba(255, 255, 255, 0.76); position: absolute; top: 0; left: 0; font-size: 12px; padding: 0.25em; }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
    <script>
        (function ($, document, window, undefined) {
            "use strict";

            var ResPhrame = function (ele, opts) {
                /** Responsive Frame
                **/
                var self = this;
                self.ele = ele;
                self.$ele = $(ele);
                self.container = self.$ele.parent();
                self.marks = $('.marks');
                self.snapsContainer = $('.markers');
                self.url = $('.url');
                self.bounce = $('.bounce');

                /** Private Functions **/

                var caretPosition = function (ele) {
                    /** TODO: only working for webkit/moz
                    **/
                    if (ele.selectionStart) { // webkit/moz
                        return ele.selectionStart;
                    } else if (document.selection && document.selection.createRange) { // IE
                        //var range = document.selection.createRange();
                    }

                    return false;
                }

                var parseLocation = function () {
                    /** extract the width and URL from the document location
                    **/

                    // extract the data we need from the location object
                    var newURL = self.options.initialURL;
                    var pairs = document.location.search.substring(1).split('&');

                    for (var i = 0; i < pairs.length; i++) {
                        var pair = pairs[i].split('=');
                        if (pair[0] == 'url') {
                            newURL = decodeURIComponent(pair[1]);
                        }
                    }

                    return {
                        frameWidth: document.location.hash.substring(1),
                        frameURL: newURL //document.location.search.substring(5)
                    };
                }

                /** Public Functions **/

                self.init = function () {
                    self.options = $.extend({}, ResPhrame.defaults, opts);

                    self.renderHandle();
                    self.updateMarksInput();
                    self.setURL();
                    self.setWidth();

                    //self.handle.on('mousedown.resphrame', function (evt) {
                    //    /** cover the whole thing coz we're only after mousemove
                    //    and mouseup events now!
                    //    **/
                    //    var cover = $('<div>');
                    //    cover.addClass('cover');
                    //    cover.show();

                    //    // add class and bring to front (for dragging).
                    //    handle.addClass('draggable').css('z-index', 1000);

                    //    // grab and set the pertinent values.
                    //    z_idx = handle.css('z-index'),
                    //    drg_h = handle.outerHeight(),
                    //    drg_w = handle.outerWidth(),
                    //    pos_y = handle.offset().top + drg_h - e.pageY,
                    //    pos_x = handle.offset().left + drg_w - e.pageX;
                    //});

                    // Make sure default dragging behaviour still applies
                    // stops $(window) below getting (and then preventing) the event.
                    $('.book a').on('dragstart', function (evt) { evt.stopPropagation(); });
                    // Stops the default dragging behaviour overtaking/interrupting what we're attempting to do.
                    $(window).on('dragstart.resphrame', function (evt) { evt.preventDefault(); });
                    // Listening for changes in the URL
                    $(window).on('popstate.resphrame', self.updateFrame);
                    // Watching for keystrokes (so we can hijack refreshes)
                    $(window).on('keydown.resphrame', self.interceptReload);

                    self.url.on('change.resphrame', 'input', self.updateURLInput);
                    // clicking on a snap-mark updates the container width
                    self.marks.on('click.resphrame', 'input', self.snapClick);
                    self.marks.on('change.resphrame', 'input', self.updateMarksInput);
                    self.bounce.on('click.resphrame', self.bounceClick);
                    // ignore normal clicks on the handle
                    self.handle.on('click.resphrame', function (evt) { evt.preventDefault(); });

                    console.log(history.state);
                    return self;
                };

                self.setURL = function (newURL) {
                    var newState = $.extend({}, parseLocation(),
                             history.state, { frameURL: newURL })
                    var stateURL = '?url=' + newState.frameURL +
                             ((newState.frameWidth) ? '#' + newState.frameWidth : '');
                    // put our URL into the history
                    // pushState for URL updates so navigation feels normal
                    history.pushState(newState, '', stateURL);
                    console.log('pushState', newState);

                    return self.updateFrameSrc();
                };

                self.setWidth = function (newWidth) {
                    var newState = $.extend({}, parseLocation(),
                            history.state, { frameWidth: newWidth })
                    // replaceState for width changes, changing the width isn't
                    // excatly something we need to be able to navigate
                    history.replaceState(newState, '', '#' + newState.frameWidth);
                    console.log('replaceState', newState);

                    return self.updateFrameSize();
                };

                self.updateFrame = function () {
                    self.updateFrameSize();
                    self.updateFrameSrc();

                    return self;
                };

                self.updateFrameSize = function () {
                    /** Resize the iframe container to frameWidth, depending on
                    the type of browser
                    **/
                    var newWidth = history.state.frameWidth || self.options.initialWidth;
                    (self.container.width() == newWidth) || self.container.width(newWidth);

                    console.log(history.state);
                    return self.updateHandle();
                };

                self.updateFrameSrc = function (force) {
                    /** update/refresh the src element on the iframe
                    **/
                    var newURL = history.state.frameURL || self.options.initialURL;
                    // only update if we are forced, or the url is something new
                    if (force || self.$ele.attr('src') !== newURL) {
                        self.$ele.attr('src', newURL);
                    }

                    console.log(history.state);
                    return self;
                };

                self.updateURLInput = function () {
                    // If the URL is changed ... change it (in iframe and history).
                    if (!this.value) {
                        this.value = parseLocation().frameURL;
                    }

                    self.setURL(this.value);
                };

                self.updateMarksInput = function () {
                    /** If the markers string is changed ... check it! change
                    it! and re-render that baby!
                    **/
                    var newSnaps = (self.marks.find('input').val())
                            ? self.marks.find('input').val().split(self.options.snapsDivider)
                            : self.options.snaps;
                    self.options.snaps = [];

                    // ensure numerics and push snap points into our array
                    for (var snap in newSnaps) {
                        var point = parseInt(newSnaps[snap]);
                        if (point && point >= self.options.lowerLimit) {
                            self.options.snaps.push(point)
                        }
                    }

                    // write the new snap positions back out to the input
                    self.options.snaps.sort(function (a, b) {
                        return a - b;
                    });
                    self.marks.find('input').val(self.options.snaps.join(self.options.snapsDivider));
                    // redraw the snap points
                    self.renderSnaps();

                    return self;
                };

                self.renderSnaps = function () {
                    /* Draw out the gridline widths for the snap targets, unlike
                    Handle, these are simply destroyed and recreated as needed
                    */
                    self.snapsContainer.empty();
                    for (var i = self.options.snaps.length - 1; i >= 0; i--) {
                        var width = parseInt(self.options.snaps[i]);
                        var mark = $('<div>');
                        mark.addClass('mark');
                        mark.text(width);
                        mark.css({ left: (width / 2) });
                        self.snapsContainer.append(mark);
                    }

                    return self;
                };

                self.snapClick = function (evt) {
                    /** clicking on a snap point resizes the frame
                    **/
                    var target = evt.target || window.event.srcElement;
                    var points = target.value;
                    // find the previous comma
                    var start = points.slice(0, caretPosition(target) || 0).lastIndexOf(self.options.snapsDivider) + 1 || 0;
                    // find the next separator
                    var end = points.indexOf(self.options.snapsDivider, caretPosition(target) || 0);
                    // adjust the end position when it's the last item
                    end = (end === -1) ? points.length : end;

                    var point = points.slice(start, end);
                    // all the transitions! ... did we miss any?
                    var transitions = [
                        'transitionend',
                        'otransitionend',
                        'oTransitionEnd',
                        'msTransitionEnd',
                        'webkitTransitionEnd'
                    ].join(' ');

                    self.container.css({ transition: 'width 0.4s ease-in' });
                    self.container.on(transitions, function () {
                        // remove the transition when we're done
                        self.container.css({ transition: '' });
                        self.updateHandle();
                    });

                    return self.setWidth(point);
                };

                self.bounceClick = function (evt) {
                    evt.preventDefault();
                    window.location.href = history.state.frameURL;
                };

                self.renderHandle = function () {
                    /** Build and output the draggable handle
                    **/
                    self.handle = $('<a>');
                    self.handle.attr('href', '#');
                    self.handle.addClass('handle');
                    self.handle.text('');
                    self.handle.prependTo(self.container);

                    return self.updateHandle();
                };

                self.updateHandle = function () {
                    /** Calculate iframe (container) dimensions, update the
                    handle's left position and output the new dimensions to the
                    handle for all to see.
                    **/
                    var frameWidth = self.container.width(),
                        iDoc, ems;

                    if (self.handle) {
                        try {
                            // get the calculated body font size for the iframe
                            // only works with a lax cross-domain security policy
                            // Google Chrome: --disable-web-security;
                            // Safari: Developer Menu "Disable local file restrictions"
                            iDoc = (self.ele.contentWindow || self.ele.contentDocument);
                            iDoc = iDoc.document || iDoc;

                            if (self.ele.currentStyle) {
                                self.options.baseFontSize = iDoc.body.currentStyle['fontSize'];
                            } else if (window.getComputedStyle) {
                                self.options.baseFontSize = window.getComputedStyle(iDoc.body).getPropertyValue('font-size').replace('px', '');
                            }
                        } catch (err) {
                            // abandon all hope if it doesn't work, our default
                            // width will have to do
                        }

                        ems = Math.round((frameWidth / self.options.baseFontSize), 0);
                        self.handle.text(frameWidth + 'px : ' + ems + 'em');
                    }

                    return self;
                };

                self.handleMousedown = function () {
                };

                self.handleDrag = function () {
                };

                self.handleMouseup = function () {
                    cover.hide();
                    handle.removeClass('draggable').css('z-index', z_idx);
                    var num = container.width();
                    // document.location.href = '#'+num;
                    // use replaceState for drag & drop, we don't need to traverse
                    // the history of our frame sizes
                    history.replaceState({ number: num }, '', '#' + num);
                };

                self.interceptReload = function (evt) {
                    /* Catch f5, <ctrl>-r, <cmd>-r keystrokes and reload the
                    frame instead
                    */
                    if ((evt.keyCode == 82 && (evt.ctrlKey || evt.metaKey)) || evt.keyCode === 116) {
                        evt.preventDefault();
                        // refresh iframe.
                        self.$ele.attr('src', function (i, val) {
                            return val;
                        });
                    }

                    return self;
                };

                // self initializing?
                //self.init();
            };

            ResPhrame.defaults = {
                snaps: [320, 480, 768, 1024, 1280],
                snapsDivider: ',',
                lowerLimit: 240,
                initialURL: 'http://www.google.com',
                initialWidth: 240 * Math.floor(Math.random() * 784),
                // default to browser user-agent base size
                baseFontSize: 16
            };

            $.fn.resPhrame = function (options) {
                return this.each(function () {
                    (new ResPhrame(this, options).init());
                });
            };
        }(jQuery, document, window));

        $(document).ready(function () {
            $('#iframe').resPhrame({ initialURL: 'http://morganesque.com' });

            // array for snap/marks in background.
            var snaps = [320, 480, 768, 1024, 1280];
            // smallest width of viewport.
            var lowerLimit = 240;
            // default starting URL (well wouldn't you?)P
            var currentURL = 'http://morganesque.com/';
            if (document.location.search.substr(5) !== '') {
                // checking we don't already have a new URL.
                currentURL = document.location.search.substr(5);
            }
            // default starting width (random).
            var initialWidth = 240 + Math.floor(Math.random()*784);
            var currentWidth = initialWidth;
            // grab the .wrapper container div and add in the handle.
            var container = $('.wrapper').css({position:'relative'});
            // grab the cover (for preventing stray mouse events)
            var cover = $('.cover');
            // width of the full window.
            var winw = $(window).width();
            // a few vars for helping drag
            var z_idx, drg_h, drg_w, pos_y, pos_x;
            // the handle (added above).
            var handle = $('.handle');
            // global storage for keystroke capture
            var keysDown = [];

            //// Listen for mousemove at the highest level.
            //$(window).on("mousemove", function (e) {
            //    if (handle.hasClass('draggable')) {
            //        var t = e.pageY + pos_y - drg_h;
            //        var l = e.pageX + pos_x - drg_w;
            //        var answer = 2 * (l - winw/2);

            //        if (answer < lowerLimit) {
            //            answer = lowerLimit;
            //            l = winw/2 + lowerLimit/2;
            //        } else {
            //            var snap = 20;
            //            for (var i = snaps.length - 1; i >= 0; i--) {
            //                var n = snaps[i];
            //                if (Math.abs(answer-n) < snap) {
            //                    answer = n;
            //                    l = 1 + winw/2 + n/2;
            //                }
            //            }
            //        }

            //        handle.css({ top: Math.round(t, 0) + 'px' });
            //        setFrameSize(answer)
            //    }
            //}).on("mouseup", function () { // mouseup end it all...
            //});
        });
    </script>
</head>
<body>
    <div class="markers"></div>
    <div class="wrapper"><iframe id="iframe" src=""></iframe></div>
    <label class="url controls"><input type="text" value="" placeholder="http://"/>URL</label>
    <label class="marks controls"><input type="text" value=""/>marks</label>
    <div class="info controls"><a href="#" class="bounce">bounce</a></div>
    <!-- div class="book"><p>Here's a<br />bookmarklet!</p><a title="Open in Resphrame" href="javascript:(function(){(function(e,t){var url='http://morganesque.github.io/resphrame/?'+'url='+e.location.href;e.location.href=url;})(window)})();">↔ Resphrame</a></div -->
</body>
</html>
